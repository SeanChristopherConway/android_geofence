/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.adampash.androidgeofence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import android.content.Intent;
import android.os.Bundle;
import android.app.PendingIntent;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
import com.google.android.gms.common.api.ResultCallback;
import com.google.android.gms.common.api.Status;
import com.google.android.gms.location.Geofence;
import com.google.android.gms.location.GeofencingRequest;
import com.google.android.gms.location.LocationServices;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

@Kroll.module(name = "Androidgeofence", id = "com.adampash.androidgeofence")
public class AndroidgeofenceModule extends KrollModule implements
		ConnectionCallbacks, OnConnectionFailedListener, ResultCallback<Status> {

	// Standard Debugging variables
	private static final String TAG = "AndroidgeofenceModule";
	protected ArrayList<Geofence> mGeofenceList;
	private KrollFunction callback = null;
	private PendingIntent mGeofencePendingIntent;
	/**
	 * Provides the entry point to Google Play services.
	 */
	protected GoogleApiClient mGoogleApiClient;
	TiApplication appContext = TiApplication.getInstance();

	/**
	 * Used to keep track of whether geofences were added.
	 */
	private boolean mGeofencesAdded;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;

	public AndroidgeofenceModule() {
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
		Log.d(TAG, "inside onAppCreate");
		// put module init code that needs to run when the application is
		// created
	}

	/*
	 * private void initializeLocationManager() { if (callback != null) {
	 * HashMap event = new HashMap(); event.put("type",
	 * "initialize location manager"); callback.call(getKrollObject(), event); }
	 * }
	 */

	/**
	 * Gets a PendingIntent to send with the request to add or remove Geofences.
	 * Location Services issues the Intent inside this PendingIntent whenever a
	 * geofence transition occurs for the current list of geofences.
	 * 
	 * @return A PendingIntent for the IntentService that handles geofence
	 *         transitions.
	 */
	private PendingIntent getGeofencePendingIntent() {
		// Reuse the PendingIntent if we already have it.
		if (mGeofencePendingIntent != null) {
			return mGeofencePendingIntent;
		}
		Intent intent = new Intent(appContext,
				GeofenceTransitionsIntentService.class);
		// We use FLAG_UPDATE_CURRENT so that we get the same pending intent
		// back when calling
		// addGeofences() and removeGeofences().
		return PendingIntent.getService(appContext, 0, intent,
				PendingIntent.FLAG_UPDATE_CURRENT);
	}

	/**
	 * Builds and returns a GeofencingRequest. Specifies the list of geofences
	 * to be monitored. Also specifies how the geofence notifications are
	 * initially triggered.
	 */
	private GeofencingRequest getGeofencingRequest() {
		GeofencingRequest.Builder builder = new GeofencingRequest.Builder();

		// The INITIAL_TRIGGER_ENTER flag indicates that geofencing service
		// should trigger a
		// GEOFENCE_TRANSITION_ENTER notification when the geofence is added and
		// if the device
		// is already inside that geofence.
		builder.setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER);

		// Add the geofences to be monitored by geofencing service.
		builder.addGeofences(mGeofenceList);

		// Return a GeofencingRequest.
		return builder.build();
	}

	public void createGeofences(double lon, double lat, float radius,
			String identifier) {

		mGeofenceList.add(new Geofence.Builder()
		// Set the request ID of the geofence. This is a string to identify this
		// geofence.
				.setRequestId(identifier)

				// Set the circular region of this geofence.
				.setCircularRegion(lat, lon, radius)

				// Set the expiration duration of the geofence. This geofence
				// gets automatically
				// removed after this period of time.
				.setExpirationDuration(Geofence.NEVER_EXPIRE)

				// Set the transition types of interest. Alerts are only
				// generated for these
				// transition. We track entry and exit transitions in this
				// sample.
				.setTransitionTypes(
						Geofence.GEOFENCE_TRANSITION_ENTER
								| Geofence.GEOFENCE_TRANSITION_EXIT)

				// Create the geofence.
				.build());
	}

	@Kroll.method
	public void startMonitoringForRegions(String regions,
			KrollFunction _callback) throws JSONException {
		JSONArray jsonarray = new JSONArray(regions);

		mGeofenceList = new ArrayList<Geofence>();
		for (int i = 0; i < jsonarray.length(); i++) {

			JSONObject region = jsonarray.getJSONObject(i);

			JSONObject center = region.getJSONObject("center");

			Double lat = center.getDouble("latitude");

			Double lng = center.getDouble("longitude");

			int radius = region.getInt("radius");

			String identifier = region.getString("identifier");

			System.out.println(lat);

			System.out.println(lng);

			System.out.println(radius);

			createGeofences(lng, lat, radius, identifier

			);

		}
		mGoogleApiClient = new GoogleApiClient.Builder(appContext)
				.addApi(LocationServices.API).addConnectionCallbacks(this)
				.addOnConnectionFailedListener(this).build();
		mGoogleApiClient.connect();

		try {
			LocationServices.GeofencingApi.addGeofences(mGoogleApiClient,
			// The GeofenceRequest object.
					getGeofencingRequest(),
					// A pending intent that that is reused when calling
					// removeGeofences(). This
					// pending intent is used to generate an intent when a
					// matched geofence
					// transition is observed.
					getGeofencePendingIntent()).setResultCallback(this); // Result
																			// processed
																			// in
																			// onResult().
		} catch (SecurityException securityException) {
			// Catch exception generated if the app does not use
			// ACCESS_FINE_LOCATION permission.
			// logSecurityException(securityException);
		}
	}

	@Override
	public void onResult(Status arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onConnectionFailed(ConnectionResult arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onConnected(Bundle arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onConnectionSuspended(int arg0) {
		// TODO Auto-generated method stub

	}

}
